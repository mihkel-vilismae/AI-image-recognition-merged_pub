<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Phone Publisher</title>
</head>
<body>
<button id="btnStart">Start camera</button>
<button id="btnCopyLogs" type="button">Copy logs</button>
<pre id="log"></pre>
<pre id="error" style="color:#b91c1c;border:1px solid #ef4444;padding:8px"></pre>
<script>
const SIGNALING_URL = "ws://__PC_LAN_IP__:8765";
let pc, ws, stream;
let sentCandidates = 0;
let recvCandidates = 0;
let heartbeatTimer = null;
let remoteAnswerApplied = false;
let remoteAnswerSdp = "";
let applyingRemoteAnswer = false;
let pendingRemoteCandidates = [];
const seenRemoteCandidateKeys = new Set();
const logEl = document.getElementById("log");
const errorEl = document.getElementById("error");
const ts = () => new Date().toISOString();
const push = (lvl, tag, msg, data) => {
  const suffix = data == null ? "" : " " + (typeof data === "string" ? data : JSON.stringify(data));
  const line = "[" + ts() + "] [" + lvl + "] [" + tag + "] " + msg + suffix;
  (lvl === "ERR" ? errorEl : logEl).textContent += line + "\n";
  if (lvl === "ERR") errorEl.style.background = "#fee2e2";
};
window.onerror = (message, source, lineno, colno, err) => {
  push("ERR", "ERR", "window.onerror", { message, source, lineno, colno, stack: err && err.stack ? err.stack : undefined });
};
window.onunhandledrejection = (event) => {
  push("ERR", "ERR", "unhandledrejection", { reason: String(event.reason) });
};
document.getElementById("btnCopyLogs").onclick = async () => {
  const text = "LOG\n" + logEl.textContent + "\nERROR\n" + errorEl.textContent;
  try { await navigator.clipboard.writeText(text); push("INFO", "STEP", "logs copied"); }
  catch (e) { push("ERR", "ERR", "copy logs failed", String(e)); }
};
const sendHeartbeat = () => {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  const v = stream ? stream.getVideoTracks()[0] : null;
  ws.send(JSON.stringify({ type: "publisher_heartbeat", ts: Date.now(), camera: { active: Boolean(v), trackReadyState: v ? v.readyState : "none", width: v && v.getSettings ? v.getSettings().width : null, height: v && v.getSettings ? v.getSettings().height : null }, webrtc: { sending: pc ? pc.connectionState === "connected" : false } }));
};

function candidateKey(candidate) {
  if (!candidate || typeof candidate !== "object") return "invalid";
  return String(candidate.candidate || "") + "|" + String(candidate.sdpMid || "") + "|" + String(candidate.sdpMLineIndex || "");
}
function parseIncomingMessage(raw) {
  if (!raw || typeof raw !== "object") return null;
  const msg = raw;
  if (typeof msg.type === "string") return msg;
  if (typeof msg.sdp === "string") {
    const inferredType = pc && pc.signalingState === "have-local-offer" ? "answer" : "offer";
    push("INFO", "WS", "missing type; inferred", { inferredType });
    return { ...msg, type: inferredType };
  }
  return null;
}
async function applyRemoteAnswerOnce(answerSdp) {
  if (!pc) {
    push("INFO", "WEBRTC", "answer ignored: no peer connection");
    return;
  }
  if (applyingRemoteAnswer) {
    push("INFO", "WEBRTC", "answer ignored: apply in-flight");
    return;
  }
  if (remoteAnswerApplied) {
    if (answerSdp === remoteAnswerSdp) {
      push("INFO", "WEBRTC", "duplicate answer ignored");
      return;
    }
    push("INFO", "WEBRTC", "different answer ignored after apply", { signalingState: pc.signalingState });
    return;
  }
  if (pc.signalingState !== "have-local-offer") {
    push("INFO", "WEBRTC", "answer ignored due to signalingState", { signalingState: pc.signalingState });
    return;
  }

  applyingRemoteAnswer = true;
  try {
    push("STEP", "WEBRTC", "setRemoteDescription start");
    await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });
    remoteAnswerApplied = true;
    remoteAnswerSdp = answerSdp;
    push("STEP", "WEBRTC", "setRemoteDescription ok");
    if (pendingRemoteCandidates.length > 0) {
      const queue = pendingRemoteCandidates.slice();
      pendingRemoteCandidates = [];
      for (const candidate of queue) {
        try {
          await pc.addIceCandidate(candidate);
          recvCandidates += 1;
        } catch (err) {
          push("ERR", "WEBRTC", "queued addIceCandidate failed", { raw: String(err) });
        }
      }
      push("WEBRTC", "WEBRTC", "queued candidates flushed", { flushed: queue.length, recvCandidates });
    }
  } catch (err) {
    push("ERR", "WEBRTC", "setRemoteDescription failed", { name: err && err.name, message: err && err.message, raw: String(err), signalingState: pc.signalingState });
  } finally {
    applyingRemoteAnswer = false;
  }
}

document.getElementById("btnStart").onclick = async () => {
  const btn = document.getElementById("btnStart");
  btn.disabled = true;
  try {
    push("STEP", "STEP", "start clicked", { relay: SIGNALING_URL });
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      push("INFO", "CAM", "enumerateDevices", devices.map(d => ({ kind: d.kind, label: d.label, deviceId: d.deviceId })));
    } catch (e) {
      push("ERR", "CAM", "enumerateDevices failed", { name: e && e.name, message: e && e.message, raw: String(e) });
    }
    push("STEP", "CAM", "getUserMedia start", { constraints: { video: true } });
    stream = await navigator.mediaDevices.getUserMedia({ video: true });
    push("INFO", "CAM", "getUserMedia success", { tracks: stream.getTracks().length });
    ws = new WebSocket(SIGNALING_URL);
    ws.onopen = async () => {
      push("WS", "WS", "open", { url: SIGNALING_URL });
      pc = new RTCPeerConnection();
      pc.addEventListener("signalingstatechange", () => push("WEBRTC", "WEBRTC", "signalingstate", pc.signalingState));
      pc.addEventListener("icegatheringstatechange", () => push("WEBRTC", "WEBRTC", "icegatheringstate", pc.iceGatheringState));
      pc.addEventListener("iceconnectionstatechange", () => push("WEBRTC", "WEBRTC", "iceconnectionstate", pc.iceConnectionState));
      pc.addEventListener("connectionstatechange", () => push("WEBRTC", "WEBRTC", "connectionstate", pc.connectionState));
      stream.getTracks().forEach(t => {
        pc.addTrack(t, stream);
        push("INFO", "CAM", "track added", { id: t.id, kind: t.kind, label: t.label });
      });
      pc.onicecandidate = (e) => {
        if (!e.candidate) return;
        sentCandidates += 1;
        ws.send(JSON.stringify({ type: "candidate", candidate: e.candidate }));
        push("WEBRTC", "WEBRTC", "candidate sent", { sentCandidates });
      };
      try {
        push("STEP", "WEBRTC", "createOffer start");
        const offer = await pc.createOffer();
        push("STEP", "WEBRTC", "createOffer ok", { sdpSize: (offer.sdp || "").length });
        push("STEP", "WEBRTC", "setLocalDescription start");
        await pc.setLocalDescription(offer);
        push("STEP", "WEBRTC", "setLocalDescription ok");
        ws.send(JSON.stringify({ type: "offer", sdp: offer.sdp }));
        push("WS", "WS", "offer sent", { sdpSize: (offer.sdp || "").length });
      } catch (err) {
        push("ERR", "WEBRTC", "offer flow failed", { name: err && err.name, message: err && err.message, raw: String(err) });
      }
      sendHeartbeat();
      heartbeatTimer = setInterval(sendHeartbeat, 1500);
    };
    ws.onmessage = async (event) => {
      push("WS", "WS", "message", { size: String(event.data || "").length });
      let parsed;
      try {
        parsed = JSON.parse(event.data);
      } catch (err) {
        push("ERR", "WS", "json parse failed", { raw: String(event.data), error: String(err) });
        return;
      }

      const msg = parseIncomingMessage(parsed);
      if (!msg || typeof msg.type !== "string") {
        push("INFO", "WS", "message ignored: missing/unknown type");
        return;
      }

      if (msg.type === "answer") {
        if (typeof msg.sdp !== "string" || !msg.sdp) {
          push("INFO", "WEBRTC", "answer ignored: missing sdp");
          return;
        }
        await applyRemoteAnswerOnce(msg.sdp);
        return;
      }

      if (msg.type === "candidate") {
        if (!msg.candidate) return;
        const key = candidateKey(msg.candidate);
        if (seenRemoteCandidateKeys.has(key)) {
          push("INFO", "WEBRTC", "duplicate candidate ignored");
          return;
        }
        seenRemoteCandidateKeys.add(key);

        if (!pc) {
          push("INFO", "WEBRTC", "candidate ignored: no peer connection");
          return;
        }

        if (!pc.remoteDescription) {
          pendingRemoteCandidates.push(msg.candidate);
          push("INFO", "WEBRTC", "candidate queued until remote description is set", { queued: pendingRemoteCandidates.length });
          return;
        }

        try {
          recvCandidates += 1;
          await pc.addIceCandidate(msg.candidate);
          push("WEBRTC", "WEBRTC", "candidate received", { recvCandidates });
        } catch (err) {
          push("ERR", "WEBRTC", "addIceCandidate failed", { raw: String(err) });
        }
      }
    };
    ws.onerror = () => push("ERR", "WS", "error");
    ws.onclose = (event) => {
      if (heartbeatTimer) { clearInterval(heartbeatTimer); heartbeatTimer = null; }
      push("ERR", "WS", "close", { code: event.code, reason: event.reason, wasClean: event.wasClean });
    };
  } catch (e) {
    push("ERR", "ERR", "start flow failed", { name: e && e.name, message: e && e.message, raw: String(e) });
    btn.disabled = false;
  }
};
</script>
</body>
</html>
